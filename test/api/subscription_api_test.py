# coding: utf-8
"""Waylay Storage api tests.

This code was generated from the OpenAPI documentation of 'Waylay Storage'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.storage.api import SubscriptionApi
from waylay.services.storage.service import StorageService

from ..types.hal_entity_stub import HALEntityStub
from ..types.subscription_config_stub import SubscriptionConfigStub
from ..types.subscriptions_listing_stub import SubscriptionsListingStub
from ..types.subscriptions_stub import SubscriptionsStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.storage.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.storage.models import (
        HALEntity,
        SubscriptionConfig,
        Subscriptions,
        SubscriptionsListing,
    )
    from waylay.services.storage.queries.subscription_api import (
        CreateQuery,
        DeleteByQuery,
        GetQuery,
        ListQuery,
        QueryQuery,
        RemoveQuery,
        ReplaceQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def subscription_api(waylay_api_client: ApiClient) -> SubscriptionApi:
    return SubscriptionApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that SubscriptionApi api is registered in the sdk client."""
    assert isinstance(waylay_client.storage.subscription, SubscriptionApi)


def _create_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str
):
    mock_response = SubscriptionConfigStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/subscription/{bucket_name}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create(service: StorageService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for create
    Create Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    kwargs = {
        # optionally use CreateQuery to validate and reuse parameters
        "query": CreateQuery(
            store="store_example",
        ),
        "json": SubscriptionConfigStub.create_instance(),
    }
    _create_set_mock_response(httpx_mock, gateway_url, quote(str(bucket_name)))
    resp = await service.subscription.create(bucket_name, **kwargs)
    check_type(resp, SubscriptionConfig)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create with models not installed
    Create Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    kwargs = {
        "query": {
            "store": "store_example",
        },
        "json": SubscriptionConfigStub.create_json(),
    }
    _create_set_mock_response(httpx_mock, gateway_url, quote(str(bucket_name)))
    resp = await service.subscription.create(bucket_name, **kwargs)
    check_type(resp, Model)


def _delete_by_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str
):
    mock_response = HALEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/subscription/{bucket_name}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete_by(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_by
    Delete All Bucket Subscriptions
    """
    # set path params
    bucket_name = "bucket_name_example"

    kwargs = {
        # optionally use DeleteByQuery to validate and reuse parameters
        "query": DeleteByQuery(
            start_after="start_after_example",
            prefix="prefix_example",
            suffix="suffix_example",
            event_type="delete",
            channel_type="webhook",
            channel_id="channel_id_example",
            store="store_example",
            max_keys=56,
        ),
    }
    _delete_by_set_mock_response(httpx_mock, gateway_url, quote(str(bucket_name)))
    resp = await service.subscription.delete_by(bucket_name, **kwargs)
    check_type(resp, HALEntity)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_by_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_by with models not installed
    Delete All Bucket Subscriptions
    """
    # set path params
    bucket_name = "bucket_name_example"

    kwargs = {
        "query": {
            "start_after": "start_after_example",
            "prefix": "prefix_example",
            "suffix": "suffix_example",
            "event_type": "delete",
            "channel_type": "webhook",
            "channel_id": "channel_id_example",
            "store": "store_example",
            "max_keys": 56,
        },
    }
    _delete_by_set_mock_response(httpx_mock, gateway_url, quote(str(bucket_name)))
    resp = await service.subscription.delete_by(bucket_name, **kwargs)
    check_type(resp, Model)


def _get_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str, subscription_id: str
):
    mock_response = SubscriptionConfigStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/subscription/{bucket_name}/{subscription_id}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: StorageService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    subscription_id = "subscription_id_example"

    kwargs = {
        # optionally use GetQuery to validate and reuse parameters
        "query": GetQuery(
            store="store_example",
        ),
    }
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(subscription_id))
    )
    resp = await service.subscription.get(bucket_name, subscription_id, **kwargs)
    check_type(resp, SubscriptionConfig)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    subscription_id = "subscription_id_example"

    kwargs = {
        "query": {
            "store": "store_example",
        },
    }
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(subscription_id))
    )
    resp = await service.subscription.get(bucket_name, subscription_id, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = SubscriptionsListingStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/storage/v1/subscription(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: StorageService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    Query All Subscriptions
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            store="store_example",
            prefix="prefix_example",
            suffix="suffix_example",
            event_type="delete",
            channel_type="webhook",
            channel_id="channel_id_example",
            max_keys=56,
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.subscription.list(**kwargs)
    check_type(resp, SubscriptionsListing)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    Query All Subscriptions
    """
    # set path params
    kwargs = {
        "query": {
            "store": "store_example",
            "prefix": "prefix_example",
            "suffix": "suffix_example",
            "event_type": "delete",
            "channel_type": "webhook",
            "channel_id": "channel_id_example",
            "max_keys": 56,
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.subscription.list(**kwargs)
    check_type(resp, Model)


def _query_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str):
    mock_response = SubscriptionsStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/subscription/{bucket_name}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_query(service: StorageService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for query
    Query Bucket Subscriptions
    """
    # set path params
    bucket_name = "bucket_name_example"

    kwargs = {
        # optionally use QueryQuery to validate and reuse parameters
        "query": QueryQuery(
            start_after="start_after_example",
            store="store_example",
            prefix="prefix_example",
            suffix="suffix_example",
            event_type="delete",
            channel_type="webhook",
            channel_id="channel_id_example",
            max_keys=56,
        ),
    }
    _query_set_mock_response(httpx_mock, gateway_url, quote(str(bucket_name)))
    resp = await service.subscription.query(bucket_name, **kwargs)
    check_type(resp, Subscriptions)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_query_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for query with models not installed
    Query Bucket Subscriptions
    """
    # set path params
    bucket_name = "bucket_name_example"

    kwargs = {
        "query": {
            "start_after": "start_after_example",
            "store": "store_example",
            "prefix": "prefix_example",
            "suffix": "suffix_example",
            "event_type": "delete",
            "channel_type": "webhook",
            "channel_id": "channel_id_example",
            "max_keys": 56,
        },
    }
    _query_set_mock_response(httpx_mock, gateway_url, quote(str(bucket_name)))
    resp = await service.subscription.query(bucket_name, **kwargs)
    check_type(resp, Model)


def _remove_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str, subscription_id: str
):
    mock_response = HALEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/subscription/{bucket_name}/{subscription_id}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_remove(service: StorageService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for remove
    Delete Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    subscription_id = "subscription_id_example"

    kwargs = {
        # optionally use RemoveQuery to validate and reuse parameters
        "query": RemoveQuery(
            store="store_example",
        ),
    }
    _remove_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(subscription_id))
    )
    resp = await service.subscription.remove(bucket_name, subscription_id, **kwargs)
    check_type(resp, HALEntity)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_remove_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove with models not installed
    Delete Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    subscription_id = "subscription_id_example"

    kwargs = {
        "query": {
            "store": "store_example",
        },
    }
    _remove_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(subscription_id))
    )
    resp = await service.subscription.remove(bucket_name, subscription_id, **kwargs)
    check_type(resp, Model)


def _replace_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str, subscription_id: str
):
    mock_response = SubscriptionConfigStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/subscription/{bucket_name}/{subscription_id}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_replace(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace
    Replace Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    subscription_id = "subscription_id_example"

    kwargs = {
        # optionally use ReplaceQuery to validate and reuse parameters
        "query": ReplaceQuery(
            store="store_example",
        ),
        "json": SubscriptionConfigStub.create_instance(),
    }
    _replace_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(subscription_id))
    )
    resp = await service.subscription.replace(bucket_name, subscription_id, **kwargs)
    check_type(resp, SubscriptionConfig)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_replace_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace with models not installed
    Replace Bucket Subscription
    """
    # set path params
    bucket_name = "bucket_name_example"

    subscription_id = "subscription_id_example"

    kwargs = {
        "query": {
            "store": "store_example",
        },
        "json": SubscriptionConfigStub.create_json(),
    }
    _replace_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(subscription_id))
    )
    resp = await service.subscription.replace(bucket_name, subscription_id, **kwargs)
    check_type(resp, Model)
