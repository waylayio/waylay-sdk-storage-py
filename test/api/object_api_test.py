# coding: utf-8
"""Waylay Storage api tests.

This code was generated from the OpenAPI documentation of 'Waylay Storage'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.storage.api import ObjectApi
from waylay.services.storage.service import StorageService

from ..types.bucket_object_stub import BucketObjectStub
from ..types.hal_entity_stub import HALEntityStub
from ..types.response_list_stub import ResponseListStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.storage.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.storage.models import (
        BucketObject,
        HALEntity,
        ResponseList,
    )
    from waylay.services.storage.queries.object_api import (
        CopyOrMoveQuery,
        CreateFolderQuery,
        ListQuery,
        RemoveQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def object_api(waylay_api_client: ApiClient) -> ObjectApi:
    return ObjectApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that ObjectApi api is registered in the sdk client."""
    assert isinstance(waylay_client.storage.object, ObjectApi)


def _copy_or_move_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str, target_path: str
):
    mock_response = HALEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/bucket/{bucket_name}/{target_path}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_copy_or_move(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for copy_or_move
    Copy Or Move Object
    """
    # set path params
    bucket_name = "bucket_name_example"

    target_path = "target_path_example"

    kwargs = {
        # optionally use CopyOrMoveQuery to validate and reuse parameters
        "query": CopyOrMoveQuery(
            source="source_example",
            move=False,
            store="store_example",
        ),
    }
    _copy_or_move_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(target_path))
    )
    resp = await service.object.copy_or_move(bucket_name, target_path, **kwargs)
    check_type(resp, Union[HALEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_copy_or_move_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for copy_or_move with models not installed
    Copy Or Move Object
    """
    # set path params
    bucket_name = "bucket_name_example"

    target_path = "target_path_example"

    kwargs = {
        "query": {
            "source": "source_example",
            "move": False,
            "store": "store_example",
        },
    }
    _copy_or_move_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(target_path))
    )
    resp = await service.object.copy_or_move(bucket_name, target_path, **kwargs)
    check_type(resp, Model)


def _create_folder_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str, object_path: str
):
    mock_response = BucketObjectStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/bucket/{bucket_name}/{object_path}/(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create_folder(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create_folder
    Create Folder
    """
    # set path params
    bucket_name = "bucket_name_example"

    object_path = "object_path_example"

    kwargs = {
        # optionally use CreateFolderQuery to validate and reuse parameters
        "query": CreateFolderQuery(
            all=False,
            store="store_example",
        ),
    }
    _create_folder_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(object_path))
    )
    resp = await service.object.create_folder(bucket_name, object_path, **kwargs)
    check_type(resp, Union[BucketObject,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_folder_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create_folder with models not installed
    Create Folder
    """
    # set path params
    bucket_name = "bucket_name_example"

    object_path = "object_path_example"

    kwargs = {
        "query": {
            "all": False,
            "store": "store_example",
        },
    }
    _create_folder_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(object_path))
    )
    resp = await service.object.create_folder(bucket_name, object_path, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str, object_path: str
):
    mock_response = ResponseListStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/bucket/{bucket_name}/{object_path}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: StorageService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Objects
    """
    # set path params
    bucket_name = "bucket_name_example"

    object_path = "object_path_example"

    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            stat=False,
            recursive=True,
            all=True,
            start_after="start_after_example",
            fetch_content_type=True,
            get_as_attachment=True,
            max_keys=56,
            sign="sign_example",
            store="store_example",
            expiry_days=56,
            expiry_hours=56,
            expiry_seconds=56,
            content_length_min=0,
            content_length_max=56,
            content_type="content_type_example",
        ),
    }
    _list_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(object_path))
    )
    resp = await service.object.list(bucket_name, object_path, **kwargs)
    check_type(resp, Union[ResponseList,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    List Objects
    """
    # set path params
    bucket_name = "bucket_name_example"

    object_path = "object_path_example"

    kwargs = {
        "query": {
            "stat": False,
            "recursive": True,
            "all": True,
            "start_after": "start_after_example",
            "fetch_content_type": True,
            "get_as_attachment": True,
            "max_keys": 56,
            "sign": "sign_example",
            "store": "store_example",
            "expiry_days": 56,
            "expiry_hours": 56,
            "expiry_seconds": 56,
            "content_length_min": 0,
            "content_length_max": 56,
            "content_type": "content_type_example",
        },
    }
    _list_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(object_path))
    )
    resp = await service.object.list(bucket_name, object_path, **kwargs)
    check_type(resp, Model)


def _remove_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, bucket_name: str, object_path: str
):
    mock_response = HALEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/storage/v1/bucket/{bucket_name}/{object_path}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_remove(service: StorageService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for remove
    Remove Object Or Folder
    """
    # set path params
    bucket_name = "bucket_name_example"

    object_path = "object_path_example"

    kwargs = {
        # optionally use RemoveQuery to validate and reuse parameters
        "query": RemoveQuery(
            recursive=True,
            all=True,
            start_after="start_after_example",
            max_keys=56,
            store="store_example",
        ),
    }
    _remove_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(object_path))
    )
    resp = await service.object.remove(bucket_name, object_path, **kwargs)
    check_type(resp, Union[HALEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_remove_without_types(
    service: StorageService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove with models not installed
    Remove Object Or Folder
    """
    # set path params
    bucket_name = "bucket_name_example"

    object_path = "object_path_example"

    kwargs = {
        "query": {
            "recursive": True,
            "all": True,
            "start_after": "start_after_example",
            "max_keys": 56,
            "store": "store_example",
        },
    }
    _remove_set_mock_response(
        httpx_mock, gateway_url, quote(str(bucket_name)), quote(str(object_path))
    )
    resp = await service.object.remove(bucket_name, object_path, **kwargs)
    check_type(resp, Model)
